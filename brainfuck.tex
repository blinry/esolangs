Brainfuck is a well-known example of a minimalistic programming language, aiming for a small language syntax and small compilers. Its programs consist of only eight characters, nevertheless, it was proven to be Turing-complete.

\subsection{History}

Brainfuck was designed by Urban Müller, a Swiss physics student who in 1992 took over a small online archive for Amiga software \cite{muller1993aminet}. Back than it saw around 40 users per day, today it is the world's largest Amiga archive.

In 1993, Müller uploaded the first Brainfuck compiler on this platform \cite{muller1993240}, in the form of a machine language implementation compiling into an executable of 296 bytes. Along with it came a README with a concise language description and the sentence “Who can program anything useful with it?~:)”, and it included some quite elaborate examples, as well.

As Aminet grew, the compiler became popular amongst the Amiga community, and was later implemented for other platforms. Some thorough sources of information about Brainfuck are ref ref ref.

Brainfuck was proven Turing complete by Daniel Cristofani \cite{cristofani-universal}, by implementing a simple universal Turing machine described by Yurii Rogozhin \cite{rogozhin1996small}.

Nowadays, Brainfuck is probably the best-known esoteric programming language. It is a common programming exercise to implement a Brainfuck compiler in another language (although people also have written Brainfuck compilers in Brainfuck itself). Fans of the language succeeded to implement even smaller compilers than the original version, the smallest one is a MS-DOS binary only 98 bytes large \cite{inte1999entry}.

\subsection{Description}

In it's setup, Brainfuck bears some similarities to Turing machines:

A Brainfuck program operates on an infinite linear arrangement of memory cells, often called \emph{tape}. Each memory cell contains an unsigned byte (a number between 0 and 255), at the beginning of the program, all cells are initialized to 0. Additionally, Brainfuck maintains a pointer to one of the memory cells.

The program source code consists of a sequence of eight symbols, which are defined as follows:

\begin{description}[labelsep=1em]
    \item[\texttt{>}] Move the pointer to the right.
    \item[\texttt{<}] Move the pointer to the left.
    \item[\texttt{+}] Increment the current cell's value by 1.
    \item[\texttt{-}] Decrement the current cell's value by 1.
    \item[\texttt{.}] Output the current cell's value as an ASCII character.
    \item[\texttt{,}] Read an ASCII character from the user, write its value to the current cell.
    \item[\texttt{[}] If the current cell contains a 0, skip to the matching closing bracket.
    \item[\texttt{]}] If the current cell does not contain a 0, return to the matching opening bracket.
\end{description}

Other characters in the source code are ignored (which allows for inline documentation). While in- or decrementing, the cells' values always wrap to stay inside the range of 0 to 255.

Using the brackets, the programmer can realize a \texttt{while}-loop: The expression

\begin{quotation}
    \texttt{[}<code>\texttt{]}
\end{quotation}

will execute <code> until the current cell is 0. For example, the expression

\begin{quotation}
    \texttt{[->+<]}
\end{quotation}

will add the current cell's value to the right neighbouring cell by decrementing the current cell by one, going right, incrementing by one, going left again. This sequence is repeated until the current cell is 0.

Another gadget which we will use in the following example is

\begin{quotation}
    \texttt{+[->+]-}
\end{quotation}

which moves to the right until the current cell's value is 255. The \texttt{+} operators increment the value before each check, so that the loop will terminate when we create a 0 that way. The \texttt{-} operators reset it to it' original value before the cell or the construct is left again.

\subsection{Examples}

The following program reads a sequence of ASCII values from the user, and prints their binary representation. In order to be able to appreciate Brainfuck's unique aesthetics, it is first given in minified form:

\lstinputlisting{brainfuck/ascii-min.b}

\begin{io}
Input: !\texttt{hello}!
Output: !\texttt{0110100001100101011011000110110001101111}!
\end{io}

Let's look at it in more detail. The following commented version, can be broken down into three basic parts: Line 1 sets up the basic memory layout, which is restored for each character the user enters. The programs uses a “sentinel” cell with the special value 255 to facilitate seeking back to the end of the bit array. Line 10 reads the character, lines 11--18 implement a simple shift register to calculate the binary representation. The remaining lines print the binary digits, by calculating the digits' ASCII values (48 or 49), and finally restore the memory layout. Note that lines 21---25 could be replaced with \texttt{++++++++++++++++++++++++++++++++++++++++++++++++}, which would increment the cell's value by 48, but we wanted to demonstrate a more esoteric (and more concise) approach here, which is why the actual code increases the value by 6 eight times.

\lstinputlisting{brainfuck/ascii.b}

\subsection{Variants}

The esolangs wiki \cite{esolang}, a large database of esoteric programming topics, and informal successor of Chris Pressey's Esoteric Topics site, lists 162 articles in the “Brainfuck derivatives” category and 33 “Brainfuck equivalents”, which were all inspired by Müller's original implementation. There are variants which operate on two tapes (\textbf{DoubleFuck}), restrict the cells to binary values, thus making the \texttt{+} and \texttt{-} operations identical (\textbf{Boolfuck}). Some add more operators (like \textbf{Brainfork}, which adds a \texttt{Y} command for forking the process), others try to reduce the command set even further (\textbf{BitChanger} also works on bit cells and defines \texttt{\}} $=$ \texttt{>+}. The effect of the original \texttt{>} can be simulated with \texttt{\}<\}}).
The joke variant \textbf{Ook!} behaves exactly like Brainfuck, but it's operators are pairs of Orangutan words like “Ook. Ook?” for \texttt{>} or “Ook! Ook!” for \texttt{-}.

xxx references

Because of Müller's informal language definition, the various compiler implementations differ in various aspects:

While the general idea assumes an infinitely long tape, actual implementations of course have some kind of memory limit. The original compiler uses a tape of 30,000 cells, with the pointer starting on the leftmost one. Some implementations extend the memory array when the pointer steps out of the allocated range, others crash, others again will wrap around.

The size of one cell was one byte in the original implementation, wrapping around to 255 when subtracting from 0, and many implementations follow that design. Others use 16- or 32-bit numbers, or signed values, allowing negative numbers.

Another implementation difference is about what happens when a Brainfuck programs wants to read a byte, but there is no more input---for example, because the input was a file which has reached the end-of-file condition. In many applications, it is interesting to know that there will be no more input. Müller's implementation leaves the current cell unchanged in this case, others set it to 0, others to -1 (this requires cells which are larger than bytes).

Interestingly, Brainfuck had a much earlier predecessor: In 1964, the theoretical computer scientist Corrado Böhm designed the language $\mathcal{P}''$, to describe a specific family of Turing machines \cite{bohm1964family}. Programs in $\mathcal{P}''$ consist of word over the alphabet $\{R, \lambda, (, )\}$. Böhm showed that this language was Turing-complete long before Brainfuck was implemented.

$\mathcal{P}''$ operates on a left-infinite tape, which can contain symbols of an alphabet $\{a_0, a_1, \dots, a_n\}$. Initially, each memory cell contains $a_0$, the \emph{blank symbol}. The symbols' semantics are as follows:

\begin{description}
    \item[\boldmath$R$] Move the memory pointer to the right.
    \item[\boldmath$\lambda$] Increase the current symbol, then move the memory pointer to the left.
    \item[\boldmath$(q)$] Repeat $q$ while the current symbol does not equal the blank symbol.
\end{description}

Each Brainfuck program can be translated  to a $\mathcal{P}''$ program using the following equivalents:
\begin{align*}
    \text{\texttt{+}} &\rightarrow r = \lambda R &\text{(increase and move left, then move right)}\\
    \text{\texttt{-}} &\rightarrow r' = \overbrace{rrr\dots r}^n &\text{(the symbol will “wrap around”)}\\
    \text{\texttt{>}} &\rightarrow R\\
    \text{\texttt{<}} &\rightarrow r'\lambda &\text{(“decrement” the cell, then $\lambda$)}\\
    \text{\texttt{[}} &\rightarrow (\\
    \text{\texttt{]}} &\rightarrow )
\end{align*}

Note that $\mathcal{P}''$ only has four operators. So called \emph{one instruction set computers} (OISC) go even further, by reducing the number of operations to one. A common example is the “subtract and branch if less than or equal to zero” operation, also known as \texttt{subleq}. It takes three memory pointers $a$, $b$ and $c$ as its operands, subtracts the value at $a$ from the value at $b$, writes the result back to $b$ and jumps to $c$ if it is not positive. One can synthesise all other operators from this single one, for example, an unconditional jump:

\begin{lstlisting}
subleq a a c // jump to c, a-a is always 0
\end{lstlisting}

or addition:

\begin{lstlisting}
subleq c c 2 // c = 0 go to the next line
subleq a c 3 // c' = c-a = -a
subleq c b 4 // b = b-c' = a+b
\end{lstlisting}
