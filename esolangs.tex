\documentclass{sig-alternate}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}%lighttt

\usepackage{enumitem}
\usepackage{blindtext}
\usepackage{microtype}
    \DisableLigatures[<,>]{family=tt*}
\usepackage{filecontents}
\usepackage{listings}
    \lstset{frame=tbrl,
        numbers=left,
        numberstyle=\tiny,
        basicstyle=\ttfamily\small
        %aboveskip=10pt,
        %belowskip=10pt,
        %literate={`}{\`}1,
    }
    \lstnewenvironment{io}{\lstset{
        numbers=none,
        frameround=tttt,
        basicstyle=\sffamily,
        columns=fullflexible,
        escapechar=!
    }}{}
\usepackage{tabularx}
\usepackage{xcolor}
    \definecolor{medium-blue}{rgb}{0,0,0.5}
\usepackage{hyperref}
    \hypersetup{
        colorlinks, linkcolor={medium-blue},
        citecolor={medium-blue}, urlcolor={medium-blue}
    }
\usepackage[style=numeric,sorting=none]{biblatex}
    \addbibresource{references.bib}
\usepackage[nameinlink]{cleveref}
\usepackage[framemethod=TikZ]{mdframed}

\title{Esoteric Programming Languages}
\subtitle{A weird journey to Brainfuck, Shakespeare, Befunge, INTERCAL and Malbolge}
%\subtitle{\textit{\large We are not really esoteric, it's just that nobody pays much attention to us.}}
\numberofauthors{1}
\author{\alignauthor Sebastian Morr\\\affaddr{Technical University Braunschweig}\\\email{sebastian@morr.cc}}

\makeatletter
\def\@copyrightspace{\relax}
\makeatother
\pagenumbering{arabic}

\begin{document}
\maketitle

\begin{abstract}
    There is this class of programming languages that are not designed to be used for programming. These so-called “esoteric” programming languages have other purposes instead: To entertain, to be beautiful, or to make a point.

    This paper describes and contrasts five stereotypical, widely different esoteric programming languages: Brainfuck, Shakespeare, Befunge, INTERCAL and Malbolge.
\end{abstract}

\section{Introduction}

While programming languages are normally designed to be used productively and being helpful in real-world applications, esoteric programming languages have other goals:

They can be proof-of-concepts, demonstrating how minimal a language syntax can get, while still maintaining an universal character. They might help to prove mathematical theorems or provide bounds in complexity analyses. The design of esoteric programming languages can be seen an art form, and be an expression of human intellect, wit, and aesthetic taste. Or they might be created as a kind of competitive sport, a challenge for the language's designer or for its users. Finally, there are joke languages designed to enjoy the authors themselves, the users, or even the readers of the specification.

The term “esoteric” stems from the ancient Greek \emph{esoterikos}, meaning “belonging to an inner circle”, and originally referred to Pythagoras' secret teachings. ref It evolved to mean “mystic”, or “having to do with highly theoretical concepts without obvious practical application”. The first usage of the term “esoteric” in the context of “weird programming languages” was probably on a web site called \emph{Esoteric Topics in Computer Programming}, published by Chris Pressey, inventor of Befunge, around 1997 \cite{pressey2005chris}.

For this paper, I picked four well-known esoteric programming languages, that each demonstrate a unique property commonly found in other esoteric languages: \textbf{Brainfuck} attempts to have a \textit{minimal} syntax, which consists only of eight different characters. Nevertheless, it can be shown to be Turing-complete. \textbf{Shakespeare} requires its programs to look like Shakespearean plays, making it a \textit{themed} language. The author(s) of \textbf{INTERCAL} attempted to create a \textit{weird} language, that differed from other languages known at that time in as many aspects as possible. \textbf{Befunge} is a \textit{two-dimensional} language, the user can use directional commands to control the program flow. Finally, \textbf{Malbolge} was designed to be as hard as possible to use, it took two years to write the first program.

For each language, we are going to look at it's origins, history, and nowadays significance, explain how the language works, give an interesting example and mention some popular variants.

\section{Preliminaries}

We first define some terms which are relevant when discussing esoteric programming languages.

\subsection{Turing machines}

In his 1937 paper \cite{turing1937computable}, Alan Turing defined a simple machine that defines “computing”. It consists of an infinite one-dimensional tape with cells that can hold symbols, a head which moves over the tape and can read and write symbols, and a finite state machine, which specifies what to do when a specific symbol is read. This simple architecture is so mighty that it can simulate all other models of computers, and thus is able to compute every computable sequence.

In fact, one construct a Turing machine that reads a description of another Turing machine, plus some input, and then simulates that other machine, this is what we call a \emph{universal Turing machine}.

\subsection{Turing completeness}

Systems are called \emph{Turing complete}, if they can be used to simulate universal Turing machines. These systems are as mighty as the class of Turing machines, meaning they can compute any computable sequence.

Turing completeness is an important property of omnipotent programming languages. It is highly probable that all modern general-purpose programming languages are Turing complete, but not all esoteric programming languages are, which makes it interesting to look at this property.

\subsection{Turing tarpit}

The language is an example of a so-called \emph{Turing tarpit}. This term was coined in 1992 by Alan Perlis, first recipient of the Turing Award, who warned against environments “in which everything is possible but nothing of interest is easy” \cite{perlis1982epigrams}, in reference to geologic asphalt lakes, whose thick consistency slows down movements for everything inside. Turing tarpit languages, like Brainfuck, provide a handful of very general and flexible mechanisms, which can be used to write \emph{any} program, but it is seldomly practical to do so, because the languages provide so little abstraction that the programs get very long or complicated.

\subsection{Standard programs}

%When learning or creating a new programming language, one of the first programs to write is often one that outputs text, conventionally the string \texttt{Hello, world!}. This was made popular by the first edition of Kernighan \& Ritchie's 1978 book \emph{The C Programming Language} \cite{kernighan1978c}. A hello world program shows that it's possible to compile/interpret a simple program and that it can output text.

%The second standard program is called “99 Bottles of Beer”, which print the text of an North American folk song. The song consists of lines like “99 bottles of beer on the wall, 99 bottles of beer. Take one down, pass it around, 98 bottles of beer on the wall...” until there are no more bottles left. The ability to program this shows that the language can handle loops and aborting conditions.

%Another standard program is a \emph{Quine}, a program which prints out its own source code. Usually, it is considered cheating to open the source file and reading from it; instead, the source code must contain all information to reproduce itself. The term was coined by Douglas Hofstadter \cite{hofstadter1979godel} in the honour of Willard Van Orman Quine, an American philosopher who studied self-referentiality, and was later applied to self-replicating programs. The first known quine appeared in a 1972 article by Paul Bratley and Jean Millo and was written in a variant of ALGOL \cite{bratley1972computer}.

\newpage
\section{Brainfuck}

\input{brainfuck.tex}

\newpage
\section{Shakespeare}

\input{shakespeare.tex}

\newpage
\section{Malbolge}

\input{malbolge.tex}

\newpage
\section{INTERCAL}

\input{intercal.tex}

\newpage
\section{Befunge}

\input{befunge.tex}

\newpage

\section{Conclusion}

\blindtext[4]

\printbibliography

\end{document}
